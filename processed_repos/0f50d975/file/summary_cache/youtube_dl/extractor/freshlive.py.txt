Summary of the code in ./youtube-dl/youtube_dl/extractor/freshlive.py

- Purpose
  - Implement an extractor (FreshLiveIE) for videos on freshlive.tv to be used by youtube-dl.
  - Retrieve video metadata and formats (HLS) and expose standard fields (title, description, uploader, timestamps, counts, etc.).

- Key class
  - FreshLiveIE(InfoExtractor): Inherits from youtube-dl's InfoExtractor.

- URL pattern
  - _VALID_URL = r'https?://freshlive\.tv/[^/]+/(?P<id>\d+)'
  - Matches URLs like https://freshlive.tv/channel/74712 and captures the numeric video ID as id.

- Testing data
  - _TEST provides a sample URL (satotv/74712) with expected info such as id, ext (mp4), title, description, thumbnail, duration, timestamp, upload_date, uploader, uploader_id, view_count, comment_count, is_live.

- Core extraction flow (_real_extract)
  1. video_id = self._match_id(url)
     - Extracts the numeric ID from the URL using the _VALID_URL pattern.

  2. webpage = self._download_webpage(url, video_id)
     - Downloads the HTML of the video page.

  3. options = self._parse_json(self._search_regex(r'window\.__CONTEXT__\s*=\s*({.+?});\s*</script>', webpage, 'initial context'), video_id)
     - Locates a JSON-like context embedded in a script tag (window.__CONTEXT__) and parses it to a Python dict.

  4. info = options['context']['dispatcher']['stores']['ProgramStore']['programs'][video_id]
     - Navigates the parsed context to obtain the program-specific data for this video.

  5. title = info['title']

  6. If the program status is 'upcoming':
     - Raise ExtractorError('Stream %s is upcoming' % video_id, expected=True)
     - This signals that the stream is not yet available.

  7. stream_url = info.get('liveStreamUrl') or info['archiveStreamUrl']
     - Prefer liveStreamUrl if present; otherwise fall back to archiveStreamUrl.

  8. is_live = info.get('liveStreamUrl') is not None

  9. formats = self._extract_m3u8_formats(stream_url, video_id, 'mp4', 'm3u8_native', m3u8_id='hls')
     - Parse the HLS manifest to produce available video formats.

  10. If is_live: title = self._live_title(title)
      - Adjust title for live streams (e.g., prefix with LIVE).

  11. Return a dict with standard fields:
      - id: video_id
      - formats: formats
      - title: title
      - description: info.get('description')
      - thumbnail: info.get('thumbnailUrl')
      - duration: int_or_none(info.get('airTime'))
      - timestamp: unified_timestamp(info.get('createdAt'))
      - uploader: try_get(info, lambda x: x['channel']['title'], compat_str)
      - uploader_id: try_get(info, lambda x: x['channel']['code'], compat_str)
      - uploader_url: try_get(info, lambda x: x['channel']['permalink'], compat_str)
      - view_count: int_or_none(info.get('viewCount'))
      - comment_count: int_or_none(info.get('commentCount'))
      - tags: info.get('tags', [])
      - is_live: is_live

- Important implementation details
  - Data source: The extractor reads a JSON-like structure embedded in the page (window.__CONTEXT__), then accesses ProgramStore.programs[video_id].
  - Live vs. archive: Presence of liveStreamUrl indicates a live stream; otherwise, the archiveStreamUrl is used for VOD playback.
  - Formats: Uses the m3u8_native parser to retrieve formats from an HLS manifest.
  - Robust field extraction: Uses int_or_none, unified_timestamp, and try_get to gracefully handle missing fields and type conversions.
  - Error handling: If the stream is upcoming, it raises ExtractorError with expected=True to reflect that the content is not yet available.

Overall, the extractor fetches a FreshLive page, pulls program data from an embedded context, determines the correct stream URL (live or archived), extracts usable HLS formats, handles live-updates, and returns a structured metadata dictionary along with format information.